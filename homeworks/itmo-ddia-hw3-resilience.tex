\documentclass[12pt]{article}
\usepackage[dvipsnames]{xcolor}
\usepackage{minted}
% sudo tlmgr install minted
\usepackage{hyperref}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdfpagemode=FullScreen,
}

\newenvironment{problem}{
    \par\textbf{Задание: }\ignorespaces
}

\newenvironment{solution}
{
  \par\textbf{Решение:}\par\bigbreak
  \begingroup
}
{
  \par\bigbreak\hfill$\square$%
  \par\endgroup
}

\begin{document}
 
\title{
    \large Принципы построения высоконагруженных систем \\
    \normalsize Институт прикладных компьютерных наук ИТМО
    \bigbreak 
    \LARGE
    Домашнее задание 3. \\ Стратегии устойчивости
    \bigbreak \normalsize
    Георгий Семенов \\
    \texttt{georgii.v.semenov@mail.ru} \\
    Мягкий дедлайн: Сб, 20.12.2025, 23:59 МСК \\
    Жесткий дедлайн: Сб, 27.12.2025, 23:59 МСК
}
\author{
    \color{red}{Имя Фамилия} \\
    \normalsize
    DDIA25-HW3-{\color{red}NameSurname}.pdf
}

\maketitle

\noindent\rule{\textwidth}{1pt} \bigbreak

Это домашнее задание выполняется в GitHub Classroom в вашем личном репозитории.
\textbf{Внимание:} в качестве решения на мягкий/жестий дедлайн все еще необходимо
отправить письмо, но не с файлом \texttt{.pdf}, а с ссылкой на Pull Request в вашем репозитории.

Задание можно выполнять на любом языке программирования и – соответственно –
использовать произвольный code style, однако ожидается единообразие этого стиля.
Необходимо будет пользоваться принципами SOLID и написать smoke-тесты на реализованные стратегии устойчивости.

Отдельные примеры кода для пунктов задания не требуются: ожидается, что вы тестируете
свой код в соответствующих test-кейсах. Достаточным считается покрытие
тестами всех основных сценариев работы реализованных стратегий устойчивости, т.е. в среднем 3-5 тесткейсов на каждый пункт
должно быть достаточно. Досканально проверять все граничные случаи вашего кода не требуется.
Цель тест-кейсов в этом задании – убедиться, что реализованные стратегии работают на некоторых семействах примеров.

Баллы за пункты задания снижаются за плохой стиль кода, за неудачные архитектурные решения
и за неполные тесты. Крайне рекомендуется выслать первую версию решения к мягкому дедлайну, чтобы
получить обратную связь по коду.

Обратная связь по решению будет внутри Pull Request в вашем репозитории, поэтому его необходимо будет создать.
В файле `./test.sh` вы можете указать команды для запуска ваших тестов (см. \href{https://github.com/classroom-resources/autograding-command-grader}{autograder api}).

\break

\section{Стратегии устойчивости}{}

В этой задании вам предлагается программно реализовать несколько стратегий устойчивости
для интеграции с внешним сервисом. Сервис представляет собой единственный stateless-эндпоинт,
и запрос к нему может завершиться с одним из следующих исходов:

\begin{itemize}
	\item \textbf{2xx} – успешный ответ с полезной нагрузкой в теле ответа.
	\item \textbf{4xx} – ошибка со стороны клиента (некорректный запрос, ошибка аутентификации или авторизации и т.п.).
	\item \textbf{5xx} – внутренняя ошибка сервера.
	\item \textbf{Timeout} – клиентский таймаут ожидания ответа от сервера на текущий запрос.
\end{itemize}

Мы можем рассматривать различные модели устойчивости в присутствии \textit{бюджетов} – т.е.
набора ресурсов действий, которые мы можем потратить на исполнение запроса:

\begin{itemize}
	\item \textbf{Retry budget} – максимальное количество подзапросов, которым мы можем нагрузить сервер за один запрос, в частности:
	\begin{itemize}
		\item \textbf{Fast errors budget} – <<быстрые>> ошибки на подзапросах, т.е. с быстрым временем отказа (обычно \texttt{4xx}).
		\item \textbf{Failures budget} – <<тяжелые>> ошибки, т.е. с некоторым ожидаемым временем работы до падения подзапроса (обычно \texttt{5xx}).
		\item \textbf{Timeout budget} – ошибки типа <<timeout>>, т.е. когда подзапрос завершается из-за истечения клиентского таймаута.
	\end{itemize}
	\item \textbf{Latency budget} – общее время ожидания ответа от сервера на все попытки выполнения запроса.
	\begin{itemize}
		\item в частности – \textbf{Subrequest latency budget} – время ожидания одного подзапроса.
	\end{itemize}
\end{itemize}

В рамках этого задания необходимо работать в своем репозитории внутри \href{https://classroom.github.com/a/kh3V5Pcp}{этого GitHub Classroom assignment}.
Вы можете разрабатывать на любом языке программирования, но к рекомендуемым семействам относятся:
\begin{itemize}
	\item C++, Rust
	\item Java, C\#, Kotlin
	\item Haskell, Scala
	\item Python, Go
	\item Typescript (JavaScript не рекомендуется)
\end{itemize}

\subsection{Подготовка (3 балла)}

Спроектируйте API для клиента, стратегии устойчивости которого мы будем реализовывать в этом задании.
Необходимо соблюсти следующие требования к API:

\begin{itemize}
	\item Должен быть выделен \textbf{интерфейс отправки подзапроса} к <<воображаемому серверу>> (для целей тестирования понадобится тестовая реализация этого интерфейса).
	Запрос должен завершаться с одним из четырех исходов: \texttt{2xx}, \texttt{4xx}, \texttt{5xx}, \texttt{Timeout} (т.е. зависание на условно большой срок).
	Интерфейс может быть как синхронным, так и асинхронным (например, на основе \texttt{Future}/\texttt{Promise}), однако должно быть возможно прекратить ожидание ответа.
	Интерфейс не должен принимать на вход клиентские/серверные таймауты или наборы исходов сервера.
	Ожидается, что объект, реализующий интерфейс <<воображаемого сервера>>, будет использоваться лишь единожды для одного запроса (но будет обслуживать серии подзапросов).

	\item Должен быть выделен \textbf{интерфейс клиента со стратегией устойчивости}, который принимает на вход параметры стратегии и бюджетов, а также объект, 
	реализующий \textit{интерфейс отправки подзапроса}, и возвращает ответ от сервера (либо ошибку, если стратегия исчерпала бюджеты).

	\item Должен быть выделен \textbf{интерфейс мультиклиента со стратегией устойчивости}, который принимает на вход параметры стратегии и бюджетов, а также множество объектов, 
	реализующих \textit{интерфейс отправки подзапроса}, и возвращает ответ от сервера (либо ошибку, если стратегия исчерпала бюджеты).

	\item В качестве иллюстрации вашего мини-фреймворка реализуйте базовую стратегию \texttt{default}, которая делает ровно один запрос
	(\texttt{max\_retries=1}) и рассматривает параметризуемый latency budget.

\end{itemize}

\subsection{Retries (0,75 балл + 0,75 балл за тесты)}

В модели устойчивости с \texttt{retry}-ями исполнение запроса рассматривается как последовательное исполнение
серии подзапросов, пока запрос не завершится успешно или не кончатся бюджеты (на fast errors, failures, timeouts или latency).
Реализуйте эту модель устойчивости.

\subsection{Exponential backoff retries (1 балл + 1 балл за тесты)}

Реализуйте еще одну стратегию, дополняя стратегию с \texttt{retry}-ями экспоненциальным наращиванием задержек между подзапросами в случае, если
возвращается ошибка \texttt{5xx} или \texttt{Timeout} (будем считать, что экспоненциально задерживать повторы при ошибках \texttt{4xx} не имеет смысла).

\subsection{Round-robin мультиклиент (0,75 балл + 0,75 балл за тесты)}

Реализуйте стратегию устойчивости для мультиклиента с балансировкой нагрузки по алгоритму round-robin. Иными словами,
каждый следующий подзапрос должен отправляться на следующий по порядку \textit{интерфейс отправки подзапроса} из их списка по кругу.

\subsection{Хеджирующий мультиклиент (2 балла + 2 балла за тесты)}

Реализуйте стратегию устойчивости для мультиклиента на основе \href{https://grpc.io/docs/guides/request-hedging/}{хеджирования} (см. семинарское занятие).
Сформулируем требования к этой стратегии:

\begin{itemize}
	\item Первый подзапрос должен отправляться на первый по порядку \textit{интерфейс отправки подзапроса} из их списка.
	\item Если в течение параметризуемого времени \texttt{hedging\_delay} не приходит ответ на первый подзапрос, 
	следующие подзапросы должны параллельно отправляться на оставшиеся \textit{интерфейсы отправки подзапроса}.
	\item Стратегия завершается успешно, когда приходит первый успешный ответ от любого из подзапросов.
	\item Стратегия завершается ошибкой, когда исчерпан бюджет на latency запроса (бюджетов на fast errors, failures, timeouts здесь нет,
	поскольку к каждому отдельному <<серверу>> запрос отправляется не более одного раза). \textit{Указание:
	по возможности, переиспользуйте вашу стратегию 'default' из первого пункта задания для отправки подзапросов.}
\end{itemize}

\subsection{(*) Circuit breaking (1,25 балл + 1,25 балл за тесты)}

Реализуйте стратегию, расширяющую Round-robin-мультиклиента с механизмом \textbf{circuit breaking} (разрыва цепи).
Вы можете реализовать произвольный механизм, но можно реализовать, например, один из следующих:
\begin{itemize}
	\item Если на некотором \textit{интерфейсе отправки подзапроса} за последние N запросов доля ошибок (4xx, 5xx, Timeout)
	\href{https://en.wikipedia.org/wiki/Leaky_bucket}{превышает допустимый порог}, то интерфейс выводится из пула ротации на фиксированное время T.
	\item Интерфейс выбирается на основе взвешенного round-robin, где вес интерфейса обратно пропорционален доле ошибок на нем за последние N запросов.
\end{itemize}
 
\end{document}